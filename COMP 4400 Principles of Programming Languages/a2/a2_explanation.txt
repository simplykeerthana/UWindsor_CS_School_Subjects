

Explanation of Predicates

Explaining all predicates with map example  [[1,2],[2,3],[3,1]]

Result predicate: The result predicate takes in one input variable X that would hold the resulting list. The result predicate has the following 
facts: map that has a map list, color list that has the colors, find neighbor fact that takes in the maplist and two empty list and the Regions 
list will hold the mapped regions to be colored. It also as the colorit predicated that takes the list that find_neighbors returned, the maplistt 
and colors each node in the map. Finally the valid predicate checks if the map list has any conflicts or not.  


find_neighbour predicate: 

Now we need to define the map using the list provided by map(), so with the adjacency list generated. So with the recursion statement, the find 
neighbor will take the list ([1,2], [2,3],[3,1]) and return (3,1,2). The built in member predicate will store the regions 3,2,1 as it goes via 
the conditional statement and retrieves the region points. 

So for example list map([[1,2],[2,3],[3,1]]) find_neighbour will return (3,1,2).

Map predicate:

The map predicate will have the list of map in this format map([[1,2],[2,3],[3,1]]). This section is to be changes by the TA to test multiple 
cases. 

Color Predicate: 

The color predicate will have the list of colors. The minimum list of color is 2 because of the logic of the problem, no two adjacent should have 
the same color. Right now I have the colors red green blue. You can add more colors to the comma separated list. 

color([red,green,blue]).

Colorit predicate:

Once the find_neighbors predicate return the Regions (3,1,2) for the examples I am using. The colorit predicate will take in an Regions list , 
the Color Predicate list of colors and a empty list to store  the region and color pair. Initially the first element in the list 3 will be mapped 
to the first element in the color list red. Then from the second element in the region list, the valid predicate will be called to check if the 
next color will be valid or not. In other terms the valid predicate will make sure the next adjacency region does not have the same color. The 
color predicate will exhaust to the Regions lost and will return the following list [[3, red], [1, green], [2, blue]]. Once the colorit predicate 
is done, it will return the result to the user.  


Adjacent and Valid predicate:

The adjacent predicate will take X, Y and compare if two regions are adjacent or not based on the members. The valid predicate will check if 
there are any conflicts, like for worst case scenarios like a map starting with [1,1] or has  edges like [2,2]. 

Example test and runs with different Map and Color values. 


1. map([[1,1],[2,3],[3,1]]).
    color([red,green,blue]).

     result(X).
     X = false

2. map([[1,2],[2,3],[3,1]]).
    color([red,green,blue]).

     result(X).
     X = [[3, red], [1, green], [2, blue]]

3. map([[1,2], [1,3], [2,3],[3,4], [5,6]]).
    color([red,green,blue, pink, violet]).
    
    result(X).
    X = [[5, red], [6, green], [4, red], [3, green], [1, red], [2, blue]]
    
4. map([[1,2], [1,3], [2,3],[3,4], [5,6], [5,7]]).
    color([red,green,blue,pink,violet]).

   I will be checking next 10 results. In the school server, you need to keep pressing the ;
   result(X).
    
X = [[7, red], [5, green], [6, red], [4, red], [3, green], [1, red], [2, blue]]
X = [[7, red], [5, green], [6, red], [4, red], [3, green], [1, red], [2, pink]]
X = [[7, red], [5, green], [6, red], [4, red], [3, green], [1, red], [2, violet]]
X = [[7, red], [5, green], [6, red], [4, red], [3, green], [1, blue], [2, red]]
X = [[7, red], [5, green], [6, red], [4, red], [3, green], [1, blue], [2, pink]]
X = [[7, red], [5, green], [6, red], [4, red], [3, green], [1, blue], [2, violet]]
X = [[7, red], [5, green], [6, red], [4, red], [3, green], [1, pink], [2, red]]
X = [[7, red], [5, green], [6, red], [4, red], [3, green], [1, pink], [2, blue]]
X = [[7, red], [5, green], [6, red], [4, red], [3, green], [1, pink], [2, violet]]
X = [[7, red], [5, green], [6, red], [4, red], [3, green], [1, violet], [2, red]]
X = [[7, red], [5, green], [6, red], [4, red], [3, green], [1, violet], [2, blue]]


Running on school server

madhava1@charlie:~/comp4400$ gprolog
GNU Prolog 1.4.5 (64 bits)
Compiled Feb 23 2020, 20:14:50 with gcc
By Daniel Diaz
Copyright (C) 1999-2020 Daniel Diaz
| ?- [a2].
compiling /home/madhava1/comp4400/a2.pl for byte code...
/home/madhava1/comp4400/a2.pl compiled, 30 lines read - 7103 bytes written, 21 ms

(1 ms) yes
| ?- result(X).

X = [[7,red],[5,green],[6,red],[4,red],[3,green],[1,red],[2,blue]] ? ;

X = [[7,red],[5,green],[6,red],[4,red],[3,green],[1,red],[2,pink]] ? ;

X = [[7,red],[5,green],[6,red],[4,red],[3,green],[1,red],[2,violet]] ? ;

X = [[7,red],[5,green],[6,red],[4,red],[3,green],[1,blue],[2,red]] ? ;

X = [[7,red],[5,green],[6,red],[4,red],[3,green],[1,blue],[2,pink]] ? ;

X = [[7,red],[5,green],[6,red],[4,red],[3,green],[1,blue],[2,violet]] ? ;

X = [[7,red],[5,green],[6,red],[4,red],[3,green],[1,pink],[2,red]] ? 

